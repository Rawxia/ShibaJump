<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Shiba Jump</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@600;700&display=swap');
        /* Pixel font for 8-bit text */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #f7f7f7;
            --text-color: #333;
            --accent-color: #ff6347;
            
            /* Dynamic sizes, will be set by JS based on gameScale */
            --shiba-size: 60px;
            --obstacle-size: 50px;
            --toy-size: 70px; 
            --ground-height-percent: 25%; /* Percentage of the BASE game height */
            --ground-height: 0px; /* Actual px value, set by JS */
            
            /* Biome-specific colors (default to Sky) */
            --current-sky-color: #87CEEB; /* Sky Blue */
            --current-cloud-svg: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="250" height="250" viewBox="0 0 50 50"><path fill="%23FFFFFF" d="M41.9 23.3c-1-5.6-5.8-9.8-11.4-9.8-3.7 0-7 1.8-9.1 4.5-1.3-1.2-3-2-4.9-2-3.4 0-6.1 2.8-6.1 6.1 0 .6.1 1.2.3 1.8-4.3.5-7.6 4.1-7.6 8.5 0 4.7 3.8 8.5 8.5 8.5h29.5c4.1 0 7.5-3.4 7.5-7.5 0-3.9-3-7.1-6.8-7.5z"/></svg>');
            --current-ground-color: #e0e0e0;
            --current-ground-border-color: #ccc;

            /* Base game world dimensions for internal calculations */
            --game-base-width: 800px;
            --game-base-height: 400px;

            /* Speed variables for animations, adjusted by JS */
            --ground-animation-duration: 4s;
            --clouds-animation-duration: 25s;
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: var(--current-sky-color); 
            font-family: 'Poppins', sans-serif;
            color: var(--text-color);
            overflow: hidden; /* Prevent body scroll */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight on mobile */
            transition: background-color 0.5s ease-in-out; 
        }

        #game-container {
            width: 90vw; /* Takes 90% of viewport width */
            height: 60vh; /* Takes 60% of viewport height */
            max-width: 800px; /* Never larger than 800px wide */
            max-height: 400px; /* Never larger than 400px high */
            aspect-ratio: 2 / 1; /* Maintain 2:1 aspect ratio */
            background: var(--current-sky-color); 
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden; /* Crucial to contain game elements within this boundary */
            border-radius: 20px;
            transition: background-color 0.5s ease-in-out; 
        }

        /* The game-world will now fill the game-container and be the actual rendering surface */
        #game-world {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; 
            height: 100%; 
            /* No scaling transform here, as it will be handled by scaling individual elements */
            overflow: hidden; 
        }
        
        #clouds {
            position: absolute;
            top: 0;
            left: 0;
            width: 200%; /* Double width for parallax */
            height: 100%;
            background-image: var(--current-cloud-svg); 
            background-repeat: repeat-x;
            opacity: 0.7;
            animation: moveClouds var(--clouds-animation-duration) linear infinite;
            transition: background-image 0.5s ease-in-out; 
        }

        #ground {
            width: 200%; /* Double width for parallax */
            height: var(--ground-height); 
            background: var(--current-ground-color); 
            position: absolute;
            bottom: 0;
            left: 0;
            border-top: 2px solid var(--current-ground-border-color); 
            animation: moveGround var(--ground-animation-duration) linear infinite;
            transition: background 0.5s ease-in-out, border-top-color 0.5s ease-in-out; 
        }
        
        #shiba-container {
            position: absolute;
            bottom: var(--ground-height); 
            left: 20%; 
            transform: translateX(-50%); /* Center shiba horizontally at 20% mark */
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #shiba {
            width: var(--shiba-size);
            height: var(--shiba-size);
            background-image: url('shiba.gif'); 
            background-size: contain;
            background-repeat: no-repeat;
            transition: transform 0.15s ease-out; 
        }

        #shiba-name {
            font-family: 'Press Start 2P', cursive; 
            font-size: 0.8em; 
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
            position: absolute;
            top: -25px; /* Adjust based on shiba size */
            white-space: nowrap; 
        }
        
        .invincible { animation: flash 0.5s linear infinite; }
        
        .particle {
            position: absolute;
            font-size: 20px;
            z-index: 20;
            animation: particle-poof 0.8s ease-out forwards;
        }

        .obstacle, .power-up, .toy-item {
            width: var(--obstacle-size);
            height: var(--obstacle-size);
            background-size: contain;
            background-repeat: no-repeat;
            position: absolute;
            font-size: var(--obstacle-size); /* For emoji obstacles */
            line-height: 1;
            z-index: 10;
            animation: moveItem var(--item-animation-duration) linear; 
        }
        
        .obstacle.ground-type, .power-up.ground-type, .toy-item.ground-type {
            bottom: var(--ground-height); 
        }

        .obstacle.flying-type, .power-up.flying-type, .toy-item.flying-type {
            bottom: calc(var(--ground-height) + var(--obstacle-flying-offset)); 
            font-size: var(--obstacle-size); 
        }

        /* Toy specific styles */
        .toy-item {
            width: var(--toy-size); 
            height: var(--toy-size); 
            animation: moveItem var(--item-animation-duration) linear, wiggleToy 1s ease-in-out infinite; 
            font-size: var(--toy-size); 
        }
        .toy-item.Toy1 { background-image: url('Toy1.png'); }
        .toy-item.Toy2 { background-image: url('Toy2.png'); }
        .toy-item.Toy3 { background-image: url('Toy3.png'); }

        @keyframes wiggleToy {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(-3deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(3deg); }
            100% { transform: rotate(0deg); }
        }

        /* Score & High Score positions - Relative to game-container */
        #score-container {
            position: absolute;
            top: 20px;
            left: 20px; 
            font-size: 1.5em;
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            z-index: 20;
            margin-top: 35px; /* Offset for XP bar */
        }
        #high-score-container { 
            position: absolute;
            top: 20px;
            right: 20px; 
            font-size: 1.5em;
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            z-index: 20;
        }

        #score #score-number {
            display: inline-block;
            transition: transform 0.1s ease-out, color 0.1s ease-out;
        }

        /* Score effects */
        .score-effect-1 { transform: scale(1.2); color: #FFFACD; } 
        .score-effect-2 { transform: rotate(5deg); }
        .score-effect-3 { transform: translateY(-3px); }
        .score-effect-4 { color: #ADFF2F; } 

        #splash-screen, #game-over-screen, #intro-message {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #splash-screen {
            background-color: var(--accent-color);
            color: white;
            transition: transform 0.8s cubic-bezier(0.86, 0, 0.07, 1);
            text-align: center;
            padding: 20px; 
            box-sizing: border-box; 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #splash-screen.hidden { transform: translateY(-100%); }
        
        #splash-screen h1 {
            font-family: 'Press Start 2P', cursive; 
            font-size: clamp(2em, 8vw, 4em); 
            margin-bottom: 20px;
            text-shadow: 4px 4px #8B0000, 6px 6px #000; 
            color: #FFD700; 
            white-space: nowrap; 
            overflow: hidden; 
            animation: bounceInLogo 1s ease-out forwards; 
        }
        @keyframes bounceInLogo {
            0% { transform: scale(0.5); opacity: 0; }
            60% { transform: scale(1.1); opacity: 1; }
            80% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }

        #splash-screen p { 
            font-size: clamp(0.9em, 2.5vw, 1.2em); 
            margin: 8px 0; 
            padding: 0 20px;
            line-height: 1.4; 
        }
        #splash-screen .chicken-message {
            font-size: clamp(1em, 3.5vw, 1.5em); 
            font-weight: bold;
            color: #FFD700; 
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        #splash-screen .tagline {
            margin-top: 15px; 
            margin-bottom: 25px; 
            font-size: clamp(1.2em, 3vw, 1.5em);
            font-weight: 700;
        }

        #splash-screen .instagram-handle {
            font-size: clamp(0.8em, 2vw, 1em);
            color: rgba(255, 255, 255, 0.8);
            margin-top: 15px;
        }

        #splash-screen .high-score-crown {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.8em;
            color: #FFD700; 
            display: flex;
            align-items: center;
            gap: 5px; 
            font-family: 'Press Start 2P', cursive;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #splash-screen .high-score-crown span {
            font-size: 0.8em; 
        }
        
        #xp-level-bar-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 100px; /* Base width, scales down */
            height: 20px; /* Base height, scales down */
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.5);
            z-index: 101; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em; /* Base font size, scales down */
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            white-space: nowrap; 
        }

        #xp-bar-fill {
            position: absolute; 
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background-color: #ADD8E6; 
            transition: width 0.3s ease-out;
            border-radius: 10px;
        }

        #xp-level-text {
            position: relative; 
            z-index: 1; 
        }
        
        .xp-gain-text {
            position: absolute;
            color: #FFD700; 
            font-family: 'Press Start 2P', cursive; 
            font-size: 1.2em; /* Base font size, scales down */
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8); 
            animation: xp-pop-fade 0.8s ease-out forwards; 
            pointer-events: none; 
            z-index: 102; 
            white-space: nowrap;
            /* Positioned relative to game-container, scaled by JS if needed */
        }

        @keyframes xp-pop-fade {
            0% { transform: translate(-50%, 0px) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -10px) scale(1.2); opacity: 1; }
            80% { transform: translate(-50%, -30px) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -40px) scale(0.8); opacity: 0; }
        }


        #splash-screen button {
            background-color: #fff;
            color: var(--accent-color);
            border: none;
            padding: 15px 30px;
            font-size: 1.5em;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 700;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 30px;
            animation: wiggle 2s infinite ease-in-out; 
        }
        #splash-screen button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }
        #splash-screen button.clicked {
            animation: button-pop 0.2s ease-out forwards; 
        }

        #intro-message {
            color: var(--accent-color);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        #intro-message h2 { font-size: 2.5em; margin: 0; }
        #intro-message p { font-size: 5em; margin: 0; font-weight: 700; }
        
        #game-over-screen {
            display: none;
            background-color: rgba(255, 255, 255, 0.9);
            text-align: center;
            color: var(--text-color);
            padding: 20px;
            box-sizing: border-box;
        }
        #game-over-screen h2 { font-size: 3em; margin: 0; color: var(--accent-color); }
        #game-over-screen p { font-size: 1.2em; margin: 10px 0; }
        #game-over-screen button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 20px;
        }
        #game-over-screen button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(255, 99, 71, 0.4);
        }
        #game-over-screen a { margin-top: 20px; color: var(--accent-color); text-decoration: none; font-weight: 600; }

        #new-high-score-message {
            color: var(--accent-color);
            font-size: 1.5em;
            font-weight: 700;
            margin-top: 10px;
            display: none; 
            animation: bounceIn 0.8s ease-out;
        }
        @keyframes bounceIn {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        .confetti {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: #f00; 
            animation: fall 3s ease-out forwards;
            opacity: 0;
            border-radius: 50%; 
        }
        @keyframes fall {
            0% { transform: translateY(-10px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(200vh) rotate(720deg); opacity: 0; }
        }

        /* Fire Confetti */
        .fire-confetti {
            position: absolute;
            font-size: 20px; 
            animation: fire-fall 1.5s ease-out forwards;
            opacity: 0;
            z-index: 20;
            pointer-events: none;
        }
        @keyframes fire-fall {
            0% { transform: translateY(-10px) rotate(0deg) scale(0.5); opacity: 1; }
            100% { transform: translateY(100px) rotate(360deg) scale(1.5); opacity: 0; }
        }


        /* Raindrop effect */
        .raindrop {
            position: absolute;
            width: 2px;
            height: 10px;
            background-color: rgba(173, 216, 230, 0.8); 
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            animation: rain-fall 1s linear forwards;
            z-index: 5; 
        }
        @keyframes rain-fall {
            0% { transform: translateY(-10px); opacity: 0.8; }
            100% { transform: translateY(100%); opacity: 0; } /* Use 100% relative to parent */
        }

        #invincible-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 2em;
            color: #FFD700; 
            text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
            z-index: 100;
            display: none; 
            animation: invincibility-pulse 1s infinite alternate;
            white-space: nowrap; 
        }
        #invincible-message.visible {
            display: block;
        }
        @keyframes invincibility-pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
            100% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
        }

        /* New Biome Effects CSS */
        .leaf {
            position: absolute;
            width: 15px;
            height: 15px;
            background-color: #8B4513; 
            border-radius: 0 50% 50% 50%; 
            transform: rotate(var(--rotation, 0deg));
            opacity: 0;
            animation: leaf-fall var(--duration) linear var(--delay) forwards;
            z-index: 5;
            pointer-events: none;
        }
        @keyframes leaf-fall {
            0% { transform: translateY(-10px) rotate(var(--rotation, 0deg)); opacity: 1; }
            100% { transform: translateY(100%) rotate(calc(var(--rotation, 0deg) + 360deg)); opacity: 0; } /* Use 100% relative to parent */
        }

        .dust-particle {
            position: absolute;
            width: 3px;
            height: 3px;
            background-color: rgba(255, 228, 181, 0.7); 
            border-radius: 50%;
            opacity: 0;
            animation: sand-drift var(--duration) linear var(--delay) forwards;
            z-index: 5;
            pointer-events: none;
        }
        @keyframes sand-drift {
            0% { transform: translateX(0) translateY(0); opacity: 0; }
            20% { opacity: 0.8; }
            100% { transform: translateX(var(--drift-x)) translateY(var(--drift-y)); opacity: 0; }
        }

        .snowflake {
            position: absolute;
            width: 5px;
            height: 5px;
            background-color: white;
            border-radius: 50%;
            opacity: 0;
            animation: snow-fall var(--duration) linear var(--delay) forwards; 
            z-index: 5;
            pointer-events: none;
        }
        @keyframes snow-fall {
            0% { transform: translateY(-10px) translateX(0px); opacity: 0.8; }
            100% { transform: translateY(100%) translateX(var(--drift-x)); opacity: 0; } /* Use 100% relative to parent */
        }

        .star {
            position: absolute;
            width: 3px;
            height: 3px;
            background-color: white;
            border-radius: 50%;
            opacity: 0;
            animation: star-twinkle var(--duration) ease-in-out infinite alternate;
            z-index: 5;
            pointer-events: none;
            box-shadow: 0 0 5px 2px rgba(255, 255, 255, 0.5); 
        }
        @keyframes star-twinkle {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }

        .special-effect-bubble {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            opacity: 0;
            pointer-events: none;
            animation: bubble-float var(--duration) linear forwards;
            z-index: 5;
        }
        @keyframes bubble-float {
            0% { transform: translateY(0) translateX(0); opacity: 0; }
            20% { opacity: 1; }
            100% { transform: translateY(-300px) translateX(var(--bubble-drift)); opacity: 0; }
        }


        @keyframes moveGround { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }
        @keyframes moveClouds { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }
        /* Item animation now moves them relative to the game-world's width (100% of it) */
        @keyframes moveItem { 
            from { left: 100%; } 
            to { left: calc(0% - var(--obstacle-size)); } /* Move off-screen by item's own width */
        } 
        @keyframes flash { 50% { opacity: 0.3; } }
        @keyframes particle-poof {
            0% { transform: scale(1) translateY(0); opacity: 1; }
            100% { transform: scale(0) translateY(100px); opacity: 0; }
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-1deg); }
            75% { transform: rotate(1deg); }
        }

        @keyframes button-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .crown-pop {
            animation: crown-bounce 0.8s ease-out;
        }

        @keyframes crown-bounce {
            0% { transform: scale(1); }
            25% { transform: scale(1.3); }
            50% { transform: scale(0.9); }
            75% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        /* Responsive adjustments for overall game-container on mobile */
        @media (max-width: 600px) {
            #game-container { 
                border-radius: 0; 
                height: 100vh; 
                width: 100vw; 
                /* Remove max-width/height here as it's full screen anyway */
                max-width: none;
                max-height: none;
            }
            /* Score, XP bar, etc. outside game-world should adapt */
            #score-container { font-size: 1.2em; right: auto; left: 10px; margin-top: 30px;} 
            #high-score-container { font-size: 1.2em; right: 10px;} 
            #intro-message h2 { font-size: 1.8em; }
            #intro-message p { font-size: 4em; }
            #game-over-screen h2 { font-size: 2.5em; }
            #game-over-screen p { font-size: 1.2em; }
            #splash-screen h1 { font-size: clamp(2em, 8vw, 3em); } 
            #splash-screen p { font-size: clamp(0.9em, 2.5vw, 1em); }
            #splash-screen .chicken-message { font-size: clamp(1em, 3vw, 1.3em); }
            #splash-screen .tagline { font-size: clamp(1.2em, 3vw, 1.2em); }
            #shiba-name { font-size: 0.7em; top: -20px;}
            #splash-screen button {
                padding: 10px 20px;
                font-size: 1.2em;
            }
            #splash-screen .high-score-crown {
                font-size: 1.5em;
                top: 10px;
                right: 10px;
            }
            #xp-level-bar-container {
                width: 80px;
                height: 18px;
                font-size: 0.6em;
                top: 10px;
                left: 10px;
            }
            #xp-level-text {
                line-height: 18px; /* Adjust line-height to center text vertically in the smaller bar */
            }
            #invincible-message {
                font-size: 1.5em;
            }
            .xp-gain-text {
                font-size: 1em; /* Smaller on mobile */
            }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="game-world"> 
            <div id="clouds"></div>
            <div id="ground"></div>
            <div id="shiba-container">
                <span id="shiba-name">Akari</span>
                <div id="shiba"></div>
            </div>
        </div>

        <div id="xp-level-bar-container">
            <div id="xp-bar-fill"></div>
            <span id="xp-level-text">Level: <span id="player-level">1</span></span>
        </div>
        <div id="score-container"><span>Score: </span><span id="score"><span id="score-number">0</span></span></div>
        <div id="high-score-container"><span>🏆 </span><span id="high-score">0</span></div>
        

        <div id="splash-screen">
            <h1>ShibaJump!</h1>
            <p>Tap for longer jumps and get the highest score!</p>
            <p class="chicken-message">Grab the 🍗 to become invincible!</p>
            <p>Collect Akari's toys for extra XP and bigger scores!</p>
            <p class="tagline">Can you help Akari find her way?</p>
            <div class="instagram-handle">@sebulique</div>
            <div class="high-score-crown">👑 <span id="splash-high-score">0</span></div>
            <button id="play-button">Play Game</button>
        </div>
        <div id="intro-message">
            <h2>Get ready to tap!</h2>
            <p id="countdown">3</p>
        </div>
        
        <div id="game-over-screen">
            <h2>Game Over</h2>
            <p>Your Score: <span id="final-score">0</span></p>
            <p>🏆 Best: <span id="final-high-score">0</span></p>
            <p id="new-high-score-message">Beat Your Best!</p>
            <button onclick="restartGame()">Play Again</button>
            <a href="https://www.instagram.com/sebulique" target="_blank">Visit my Instagram @sebulique</a>
        </div>

        <div id="invincible-message">Invincible!</div>
    </div>

    <script>
        const elements = {
            shibaContainer: document.getElementById('shiba-container'), 
            shiba: document.getElementById('shiba'),
            shibaName: document.getElementById('shiba-name'), 
            gameWorld: document.getElementById('game-world'), // The new game-world div
            scoreDisplay: document.getElementById('score'),
            scoreNumber: document.getElementById('score-number'), 
            highScoreDisplay: document.getElementById('high-score'),
            splashScreen: document.getElementById('splash-screen'),
            playButton: document.getElementById('play-button'), 
            introMessage: document.getElementById('intro-message'),
            countdownDisplay: document.getElementById('countdown'),
            gameOverScreen: document.getElementById('game-over-screen'),
            finalScoreDisplay: document.getElementById('final-score'),
            finalHighScoreDisplay: document.getElementById('final-high-score'),
            newHighScoreMessage: document.getElementById('new-high-score-message'),
            ground: document.getElementById('ground'),
            clouds: document.getElementById('clouds'),
            gameContainer: document.getElementById('game-container'), // The main, responsive container
            body: document.body,
            splashHighScore: document.getElementById('splash-high-score'), 
            playerLevelDisplay: document.getElementById('player-level'),
            xpBarFill: document.getElementById('xp-bar-fill'),
            xpLevelText: document.getElementById('xp-level-text'),
            highScoreCrownIcon: document.querySelector('#high-score-container span:first-child'),
            invincibleMessage: document.getElementById('invincible-message') 
        };

        const state = {
            score: 0,
            highScore: localStorage.getItem('shibaHighScore') || 0,
            isJumping: false,
            isGameOver: true,
            isInvincible: false,
            gameLoopInterval: null,
            obstacleInterval: null,
            lastObstacleInterval: 0, 
            confettiInterval: null, 
            shibaY: 0, 
            velocityY: 0, 
            gravity: 0.9, 
            jumpStrength: -20, 
            maxHoldJumpBoost: -10, 
            jumpHoldTimer: null,
            groundHeight: 0, // This will be dynamic based on scaled height
            flyingObstacleThreshold: 10, 
            currentBiomeIndex: 0, 
            lastBiomeChangeScore: 0, 
            biomeChangeInterval: 7, 
            normalObstacleInterval: 1500, 
            minObstacleInterval: 700, 
            playerXP: parseInt(localStorage.getItem('shibaPlayerXP')) || 0,
            playerLevel: parseInt(localStorage.getItem('shibaPlayerLevel')) || 1,
            xpToNextLevel: parseInt(localStorage.getItem('shibaXpToNextLevel')) || 1000, 
            biomeOrder: [], 
            biomeCurrentIndexInOrder: 0,
            bubbleInterval: null, 
            rainInterval: null,
            leafInterval: null, 
            dustInterval: null, 
            snowInterval: null, 
            starInterval: null,
            baseGameSpeed: 3, 
            obstacleBaseSpeed: 2.5, 
            toysCollectedInStreak: 0,
            
            // New for dynamic scaling based on current game-container size
            gameScale: 1, // Current scaling factor for internal game elements
            shibaBaseSize: 60, // Original pixel size
            obstacleBaseSize: 50, // Original pixel size
            toyBaseSize: 70, // Original pixel size
            // Base flying offset in original design pixels
            obstacleFlyingBaseOffset: 100, 
            xpTextBaseFontSize: 1.2, // original 1.2em
            invincibleMessageBaseFontSize: 2, // original 2em
            shibaNameBaseFontSize: 0.8, // original 0.8em
            scoreBaseFontSize: 1.5 // original 1.5em
        };
        
        const EMOJIS = {
            invincibilityPowerUp: '🍗', 
            fireConfetti: '🔥', 
            sky: {
                ground: ['🌳', '🪨', '🌲', '🪵'],
                flying: ['☁️', '🎈', '🦉']
            },
            desert: {
                ground: ['🌵', '🐍', '🏜️', '🦂'],
                flying: ['🦅', '☀️', '🌪️']
            },
            forest: {
                ground: ['🕷️', '🍄', '🌿', '🪵'],
                flying: ['🦉', '🦇', '🦋']
            },
            snow: {
                ground: ['🎄', '⛄', '🧊', '🛷'], 
                flying: ['❄️', '🌨️', '🌬️'] 
            },
            underwater: {
                ground: ['🦀', '🐡', '🐙', '🐚'], 
                flying: ['🐠', '🦑', '🐡'] 
            },
            night: {
                ground: ['🐺', '🦉', '🕸️', '🌙'],
                flying: ['🦇', '🌌', '🌟']
            },
            rainyForest: {
                ground: ['🐸', '🍄', '💦', '🪨'], 
                flying: ['🌧️', '⚡', '🦅'] 
            }
        };

        const TOY_IMAGES = ['Toy1.png', 'Toy2.png', 'Toy3.png'];

        const CONFETTI_COLORS = ['#f00', '#0f0', '#00f', '#ff0', '#0ff', '#f0f', '#FFD700', '#C0C0C0']; 

        // Biome definitions
        const BIOMES = [
            {
                name: "Sky",
                skyColor: "#87CEEB",
                cloudSvg: 'url("data:image/svg+xml;utf8,<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"250\\" height=\\"250\\" viewBox=\\"0 0 50 50\\"><path fill=\\"%23FFFFFF\\" d=\\"M41.9 23.3c-1-5.6-5.8-9.8-11.4-9.8-3.7 0-7 1.8-9.1 4.5-1.3-1.2-3-2-4.9-2-3.4 0-6.1 2.8-6.1 6.1 0 .6.1 1.2.3 1.8-4.3.5-7.6 4.1-7.6 8.5 0 4.7 3.8 8.5 8.5 8.5h29.5c4.1 0 7.5-3.4 7.5-7.5 0-3.9-3-7.1-6.8-7.5z\\"/></svg>")',
                groundColor: "#e0e0e0",
                groundBorderColor: "#ccc",
                groundObstacles: EMOJIS.sky.ground,
                flyingObstacles: EMOJIS.sky.flying,
                specialEffect: null 
            },
            {
                name: "Desert",
                skyColor: "#FFD700", 
                cloudSvg: 'url("data:image/svg+xml;utf8,<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"250\\" height=\\"250\\" viewBox=\\"0 0 50 50\\"><path fill=\\"%23FFD700\\" d=\\"M41.9 23.3c-1-5.6-5.8-9.8-11.4-9.8-3.7 0-7 1.8-9.1 4.5-1.3-1.2-3-2-4.9-2-3.4 0-6.1 2.8-6.1 6.1 0 .6.1 1.2.3 1.8-4.3.5-7.6 4.1-7.6 8.5 0 4.7 3.8 8.5 8.5 8.5h29.5c4.1 0 7.5-3.4 7.5-7.5 0-3.9-3-7.1-6.8-7.5z\\"/></svg>")', 
                groundColor: "#F4A460", 
                groundBorderColor: "#CD853F", 
                groundObstacles: EMOJIS.desert.ground,
                flyingObstacles: EMOJIS.desert.flying,
                specialEffect: 'dust'
            },
            {
                name: "Forest",
                skyColor: "#8FBC8F", 
                cloudSvg: 'url("data:image/svg+xml;utf8,<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"250\\" height=\\"250\\" viewBox=\\"0 0 50 50\\"><path fill=\\"%23ADD8E6\\" d=\\"M41.9 23.3c-1-5.6-5.8-9.8-11.4-9.8-3.7 0-7 1.8-9.1 4.5-1.3-1.2-3-2-4.9-2-3.4 0-6.1 2.8-6.1 6.1 0 .6.1 1.2.3 1.8-4.3.5-7.6 4.1-7.6 8.5 0 4.7 3.8 8.5 8.5 8.5h29.5c4.1 0 7.5-3.4 7.5-7.5 0-3.9-3-7.1-6.8-7.5z\\"/></svg>")', 
                groundColor: "#556B2F", 
                groundBorderColor: "#6B8E23", 
                groundObstacles: EMOJIS.forest.ground,
                flyingObstacles: EMOJIS.forest.flying,
                specialEffect: 'leaves'
            },
            {
                name: "Snow",
                skyColor: "#B0E0E6", 
                cloudSvg: 'url("data:image/svg+xml;utf8,<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"250\\" height=\\"250\\" viewBox=\\"0 0 50 50\\"><path fill=\\"%23F0F8FF\\" d=\\"M41.9 23.3c-1-5.6-5.8-9.8-11.4-9.8-3.7 0-7 1.8-9.1 4.5-1.3-1.2-3-2-4.9-2-3.4 0-6.1 2.8-6.1 6.1 0 .6.1 1.2.3 1.8-4.3.5-7.6 4.1-7.6 8.5 0 4.7 3.8 8.5 8.5 8.5h29.5c4.1 0 7.5-3.4 7.5-7.5 0-3.9-3-7.1-6.8-7.5z\\"/></svg>")', 
                groundColor: "#F0F8FF", 
                groundBorderColor: "#D3D3D3", 
                groundObstacles: EMOJIS.snow.ground,
                flyingObstacles: EMOJIS.snow.flying,
                specialEffect: 'snow'
            },
            {
                name: "Underwater",
                skyColor: "#4682B4", 
                cloudSvg: 'none', 
                groundColor: "#008B8B", 
                groundBorderColor: "#20B2AA", 
                groundObstacles: EMOJIS.underwater.ground,
                flyingObstacles: EMOJIS.underwater.flying,
                specialEffect: 'bubbles' 
            },
            {
                name: "Night",
                skyColor: "#1A2A3A", 
                cloudSvg: 'url("data:image/svg+xml;utf8,<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"250\\" height=\\"250\\" viewBox=\\"0 0 50 50\\"><path fill=\\"%23778899\\" d=\\"M41.9 23.3c-1-5.6-5.8-9.8-11.4-9.8-3.7 0-7 1.8-9.1 4.5-1.3-1.2-3-2-4.9-2-3.4 0-6.1 2.8-6.1 6.1 0 .6.1 1.2.3 1.8-4.3.5-7.6 4.1-7.6 8.5 0 4.7 3.8 8.5 8.5 8.5h29.5c4.1 0 7.5-3.4 7.5-7.5 0-3.9-3-7.1-6.8-7.5z\\"/></svg>")', 
                groundColor: "#36454F", 
                groundBorderColor: "#2F4F4F", 
                groundObstacles: EMOJIS.night.ground,
                flyingObstacles: EMOJIS.night.flying,
                specialEffect: 'stars'
            },
            {
                name: "Rainy Forest",
                skyColor: "#5F9EA0", 
                cloudSvg: 'url("data:image/svg+xml;utf8,<svg xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"250\\" height=\\"250\\" viewBox=\\"0 0 50 50\\"><path fill=\\"%23778899\\" d=\\"M41.9 23.3c-1-5.6-5.8-9.8-11.4-9.8-3.7 0-7 1.8-9.1 4.5-1.3-1.2-3-2-4.9-2-3.4 0-6.1 2.8-6.1 6.1 0 .6.1 1.2.3 1.8-4.3.5-7.6 4.1-7.6 8.5 0 4.7 3.8 8.5 8.5 8.5h29.5c4.1 0 7.5-3.4 7.5-7.5 0-3.9-3-7.1-6.8-7.5z\\"/></svg>")', 
                groundColor: "#4F6F4F", 
                groundBorderColor: "#364F36", 
                groundObstacles: EMOJIS.rainyForest.ground,
                flyingObstacles: EMOJIS.rainyForest.flying,
                specialEffect: 'rain'
            }
        ];

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function generateBiomeOrder() {
            const biomeIndexes = Array.from({ length: BIOMES.length }, (_, i) => i);
            shuffleArray(biomeIndexes);
            state.biomeOrder = biomeIndexes;
            state.biomeCurrentIndexInOrder = 0;
        }

        function setBiome(index) {
            const biome = BIOMES[index];
            if (!biome) return; 

            document.documentElement.style.setProperty('--current-sky-color', biome.skyColor);
            document.documentElement.style.setProperty('--current-cloud-svg', biome.cloudSvg);
            document.documentElement.style.setProperty('--current-ground-color', biome.groundColor);
            document.documentElement.style.setProperty('--current-ground-border-color', biome.groundBorderColor);
            
            elements.clouds.style.display = biome.cloudSvg === 'none' ? 'none' : 'block';

            // Clear all special effects before applying new one
            document.querySelectorAll('.special-effect-bubble, .raindrop, .leaf, .dust-particle, .snowflake, .star, .fire-confetti').forEach(el => el.remove());
            
            clearInterval(state.bubbleInterval);
            clearInterval(state.rainInterval);
            clearInterval(state.leafInterval);
            clearInterval(state.dustInterval);
            clearInterval(state.snowInterval);
            clearInterval(state.starInterval);


            if (biome.specialEffect === 'bubbles') {
                startBubbleEffect();
            } else if (biome.specialEffect === 'rain') {
                startRainEffect();
            } else if (biome.specialEffect === 'leaves') {
                startLeafEffect();
            } else if (biome.specialEffect === 'dust') {
                startDustEffect();
            } else if (biome.specialEffect === 'snow') {
                startSnowEffect();
            } else if (biome.specialEffect === 'stars') {
                startStarEffect();
            }
        }

        function startBubbleEffect() {
            state.bubbleInterval = setInterval(() => {
                if (state.isGameOver) {
                    clearInterval(state.bubbleInterval);
                    return;
                }
                const bubble = document.createElement('div');
                bubble.classList.add('special-effect-bubble');
                bubble.style.width = `${Math.random() * 10 + 5}px`;
                bubble.style.height = bubble.style.width;
                bubble.style.bottom = `${state.groundHeight}px`; 
                bubble.style.left = `${Math.random() * elements.gameWorld.clientWidth}px`; // Position relative to gameWorld
                
                const driftAmount = Math.random() > 0.5 ? 20 : -20;
                bubble.style.setProperty('--bubble-drift', `${driftAmount}px`); 
                bubble.style.setProperty('--duration', `${Math.random() * 8 + 4}s`); 
                
                elements.gameWorld.appendChild(bubble);

                setTimeout(() => bubble.remove(), parseFloat(bubble.style.getPropertyValue('--duration')) * 1000); 
            }, 300); 
        }

        function startRainEffect() {
            state.rainInterval = setInterval(() => {
                if (state.isGameOver) {
                    clearInterval(state.rainInterval);
                    return;
                }
                const raindrop = document.createElement('div');
                raindrop.classList.add('raindrop');
                raindrop.style.left = `${Math.random() * elements.gameWorld.clientWidth}px`; // Position relative to gameWorld
                raindrop.style.animationDuration = `${Math.random() * 0.8 + 0.5}s`; 
                raindrop.style.animationDelay = `${Math.random() * 1}s`; 
                elements.gameWorld.appendChild(raindrop);

                setTimeout(() => raindrop.remove(), parseFloat(raindrop.style.animationDuration) * 1000 + parseFloat(raindrop.style.animationDelay) * 1000);
            }, 50); 
        }

        function startLeafEffect() {
            state.leafInterval = setInterval(() => {
                if (state.isGameOver) {
                    clearInterval(state.leafInterval);
                    return;
                }
                const leaf = document.createElement('div');
                leaf.classList.add('leaf');
                leaf.style.left = `${Math.random() * elements.gameWorld.clientWidth}px`; // Position relative to gameWorld
                leaf.style.setProperty('--duration', `${Math.random() * 5 + 3}s`);
                leaf.style.setProperty('--delay', `${Math.random() * 2}s`);
                leaf.style.setProperty('--rotation', `${Math.random() * 360}deg`);
                elements.gameWorld.appendChild(leaf);
                setTimeout(() => leaf.remove(), parseFloat(leaf.style.getPropertyValue('--duration')) * 1000 + parseFloat(leaf.style.getPropertyValue('--delay')) * 1000);
            }, 150);
        }

        function startDustEffect() {
            state.dustInterval = setInterval(() => {
                if (state.isGameOver) {
                    clearInterval(state.dustInterval);
                    return;
                }
                const dust = document.createElement('div');
                dust.classList.add('dust-particle');
                dust.style.left = `${Math.random() * elements.gameWorld.clientWidth}px`; // Position relative to gameWorld
                dust.style.bottom = `${state.groundHeight + Math.random() * 20 * state.gameScale}px`; // Scale random offset too
                dust.style.setProperty('--duration', `${Math.random() * 3 + 1}s`);
                dust.style.setProperty('--delay', `${Math.random() * 1}s`);
                dust.style.setProperty('--drift-x', `${(Math.random() * 100 - 50) * state.gameScale}px`); // Scale drift
                dust.style.setProperty('--drift-y', `${(Math.random() * -50) * state.gameScale}px`); // Scale drift
                elements.gameWorld.appendChild(dust);
                setTimeout(() => dust.remove(), parseFloat(dust.style.getPropertyValue('--duration')) * 1000 + parseFloat(dust.style.getPropertyValue('--delay')) * 1000);
            }, 100);
        }

        function startSnowEffect() {
            state.snowInterval = setInterval(() => {
                if (state.isGameOver) {
                    clearInterval(state.snowInterval);
                    return;
                }
                const snowflake = document.createElement('div');
                snowflake.classList.add('snowflake');
                snowflake.style.left = `${Math.random() * elements.gameWorld.clientWidth}px`; // Position relative to gameWorld
                snowflake.style.setProperty('--duration', `${Math.random() * 5 + 3}s`);
                snowflake.style.setProperty('--delay', `${Math.random() * 2}s`);
                snowflake.style.setProperty('--drift-x', `${(Math.random() * 50 - 25) * state.gameScale}px`); // Scale drift
                elements.gameWorld.appendChild(snowflake);
                setTimeout(() => snowflake.remove(), parseFloat(snowflake.style.getPropertyValue('--duration')) * 1000 + parseFloat(snowflake.style.getPropertyValue('--delay')) * 1000);
            }, 80);
        }

        function startStarEffect() {
            state.starInterval = setInterval(() => {
                if (state.isGameOver) {
                    clearInterval(state.starInterval);
                    return;
                }
                const star = document.createElement('div');
                star.classList.add('star');
                star.style.left = `${Math.random() * elements.gameWorld.clientWidth}px`; // Position relative to gameWorld
                star.style.top = `${Math.random() * (elements.gameWorld.clientHeight - state.groundHeight - (50 * state.gameScale))}px`; // Scale top offset
                star.style.setProperty('--duration', `${Math.random() * 3 + 1.5}s`);
                star.style.setProperty('--delay', `${Math.random() * 2}s`);
                elements.gameWorld.appendChild(star);
                setTimeout(() => star.remove(), parseFloat(star.style.getPropertyValue('--duration')) * 1000 + parseFloat(star.style.getPropertyValue('--delay')) * 1000);
            }, 200);
        }
        
        function resizeGame() {
            const containerWidth = elements.gameContainer.clientWidth;
            const containerHeight = elements.gameContainer.clientHeight;

            // Calculate the current scale based on the smaller dimension relative to a "base" height
            // We'll treat the 400px height as our reference for scaling elements.
            // When game-container is 800x400, scale will be 1.
            // When game-container is smaller (e.g., on mobile), scale will be < 1.
            state.gameScale = containerHeight / 400; // Reference to original 400px height

            // Update CSS variables for all dynamically sized elements
            document.documentElement.style.setProperty('--shiba-size', `${state.shibaBaseSize * state.gameScale}px`);
            document.documentElement.style.setProperty('--obstacle-size', `${state.obstacleBaseSize * state.gameScale}px`);
            document.documentElement.style.setProperty('--toy-size', `${state.toyBaseSize * state.gameScale}px`); 
            
            // Flying obstacle offset
            document.documentElement.style.setProperty('--obstacle-flying-offset', `${state.obstacleFlyingBaseOffset * state.gameScale}px`);

            // Ground height is a percentage of the original game height, then scaled
            state.groundHeight = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--ground-height-percent')) / 100 * containerHeight; // This is a pixel value
            document.documentElement.style.setProperty('--ground-height', `${state.groundHeight}px`);
            
            // Adjust Shiba's vertical position relative to the new ground height
            if (!state.isJumping) {
                state.shibaY = state.groundHeight; // Shiba's Y position is now in actual pixels
                elements.shibaContainer.style.bottom = `${state.shibaY}px`;
            }
            
            // Adjust font sizes for elements outside the game-world based on scale
            elements.scoreDisplay.style.fontSize = `${state.scoreBaseFontSize * state.gameScale}em`;
            elements.highScoreDisplay.style.fontSize = `${state.scoreBaseFontSize * state.gameScale}em`;
            
            elements.xpLevelText.style.fontSize = `${0.7 * state.gameScale}em`;
            elements.xpLevelText.parentNode.style.width = `${100 * state.gameScale}px`;
            elements.xpLevelText.parentNode.style.height = `${20 * state.gameScale}px`;

            elements.invincibleMessage.style.fontSize = `${state.invincibleMessageBaseFontSize * state.gameScale}em`;
            elements.shibaName.style.fontSize = `${state.shibaNameBaseFontSize * state.gameScale}em`;
            
            // Re-adjust item bottom positions for already existing items
            document.querySelectorAll('.obstacle, .power-up, .toy-item').forEach(item => {
                if (item.classList.contains('ground-type')) {
                    item.style.bottom = `${state.groundHeight}px`;
                } else if (item.classList.contains('flying-type')) {
                    // Re-calculate flying height based on current scale
                    item.style.bottom = `calc(${state.groundHeight}px + ${state.obstacleFlyingBaseOffset * state.gameScale}px + ${Math.random() * 70 * state.gameScale}px)`;
                }
            });

            // Re-calculate and set animation speed for all moving items
            document.querySelectorAll('.obstacle, .power-up, .toy-item').forEach(item => {
                const speedMultiplier = 1 + (state.score * 0.01);
                let animationSpeed = Math.max(0.8, state.obstacleBaseSpeed / speedMultiplier);
                item.style.setProperty('--item-animation-duration', `${animationSpeed}s`);
                // Force a re-animation by briefly setting to 'none' and then back.
                // This ensures 'from' and 'to' values (like `left: 100%;`) are re-evaluated based on new container size.
                const currentAnimation = item.style.animation;
                item.style.animation = 'none';
                void item.offsetWidth; // Trigger reflow
                item.style.animation = currentAnimation;
            });
            // Update ground and clouds animation to reflect new speed
            checkGameSpeed(); 
        }

        function init() {
            // No need for --game-base-width/height here in root, they're internal reference values now.

            resizeGame(); // Set initial sizes and scale
            window.addEventListener('resize', resizeGame); // Update sizes on resize

            state.highScore = localStorage.getItem('shibaHighScore') || 0;
            state.playerXP = parseInt(localStorage.getItem('shibaPlayerXP')) || 0;
            state.playerLevel = parseInt(localStorage.getItem('shibaPlayerLevel')) || 1;
            state.xpToNextLevel = parseInt(localStorage.getItem('shibaXpToNextLevel')) || 1000;

            elements.highScoreDisplay.textContent = state.highScore;
            elements.splashHighScore.textContent = state.highScore; 
            updateXPDisplay(); // Ensure XP bar is updated on load

            elements.playButton.addEventListener('click', handlePlayButtonClick);
            elements.playButton.addEventListener('touchstart', handlePlayButtonClick);
        }

        function handlePlayButtonClick(e) {
            e.preventDefault(); 
            elements.playButton.classList.add('clicked'); 
            elements.playButton.style.animation = 'none'; 
            setTimeout(() => {
                elements.splashScreen.classList.add('hidden');
                elements.playButton.removeEventListener('click', handlePlayButtonClick);
                elements.playButton.removeEventListener('touchstart', handlePlayButtonClick);
                setTimeout(startIntro, 800);
            }, 200); 
        }

        function startIntro() {
            elements.introMessage.style.opacity = '1';
            let count = 3;
            elements.countdownDisplay.textContent = count;
            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    elements.countdownDisplay.textContent = count;
                } else {
                    clearInterval(countdownInterval);
                    elements.introMessage.style.opacity = '0';
                    setTimeout(startGame, 500);
                }
            }, 1000);
        }

        function startGame() {
            state.isGameOver = true; 
            endGameCleanup(); 
            
            state.isGameOver = false;
            state.score = 0;
            state.lastBiomeChangeScore = 0; 
            state.toysCollectedInStreak = 0; 
            elements.scoreNumber.textContent = state.score; 
            elements.gameOverScreen.style.display = 'none';
            elements.newHighScoreMessage.style.display = 'none';
            elements.playButton.classList.remove('clicked'); 
            elements.invincibleMessage.classList.remove('visible'); 
            elements.shibaContainer.style.display = 'flex'; 

            elements.ground.style.animationPlayState = 'running';
            elements.clouds.style.animationPlayState = 'running';

            state.shibaY = state.groundHeight; // Shiba Y position is now in actual pixels
            state.velocityY = 0;
            elements.shibaContainer.style.bottom = `${state.shibaY}px`; 
            elements.shiba.style.transform = `translateY(0px)`; 

            generateBiomeOrder();
            state.biomeCurrentIndexInOrder = 0;
            setBiome(state.biomeOrder[state.biomeCurrentIndexInOrder]);

            document.addEventListener('keydown', handleJumpStart);
            document.addEventListener('keyup', handleJumpEnd);
            elements.gameContainer.addEventListener('touchstart', handleJumpStart, { passive: false });
            elements.gameContainer.addEventListener('touchend', handleJumpEnd, { passive: false });
            elements.gameContainer.addEventListener('mousedown', handleJumpStart);
            elements.gameContainer.addEventListener('mouseup', handleJumpEnd);
            
            if (state.gameLoopInterval) clearInterval(state.gameLoopInterval);
            state.gameLoopInterval = setInterval(gameLoop, 20);
            
            if (state.obstacleInterval) clearInterval(state.obstacleInterval);
            state.obstacleInterval = setInterval(createItem, state.normalObstacleInterval);
            state.lastObstacleInterval = state.normalObstacleInterval; 
        }

        const handleJumpStart = (e) => {
            const isKeyEvent = e.code === 'Space';
            const isMouseEvent = e.type === 'mousedown';
            const isTouchEvent = e.type === 'touchstart';

            // Ensure click/touch is within game-container and not on a button
            const isGameAreaInteraction = elements.gameContainer.contains(e.target) && !e.target.closest('button');

            if (!state.isGameOver && !state.isJumping && (isKeyEvent || (isGameAreaInteraction && (isMouseEvent || isTouchEvent)))) {
                e.preventDefault(); 
                state.isJumping = true;
                // Jump strength also needs to scale
                state.velocityY = state.jumpStrength * state.gameScale; 
                elements.shiba.style.transform = `translateY(0px) rotate(-10deg)`; 
                
                state.jumpHoldTimer = setTimeout(() => {
                    if (state.isJumping) { 
                        state.velocityY += state.maxHoldJumpBoost * state.gameScale; 
                    }
                }, 50); 
            }
        };

        const handleJumpEnd = (e) => {
            const isKeyEvent = e.code === 'Space';
            const isMouseEvent = e.type === 'mouseup';
            const isTouchEvent = e.type === 'touchend'; 

            const isGameAreaInteraction = elements.gameContainer.contains(e.target) && !e.target.closest('button');

            if (state.isJumping && (isKeyEvent || (isGameAreaInteraction && (isMouseEvent || isTouchEvent)))) {
                if (state.jumpHoldTimer) {
                    clearTimeout(state.jumpHoldTimer);
                    state.jumpHoldTimer = null;
                }
                if (state.velocityY < 0) { 
                    state.velocityY *= 0.5; 
                }
            }
        };


        function createItem() {
            if (state.isGameOver) return;
            
            const item = document.createElement('div');
            const currentBiome = BIOMES[state.biomeOrder[state.biomeCurrentIndexInOrder]];

            const randomChance = Math.random();
            const isChickenPowerUp = randomChance < 0.05; 
            const isToyItem = !isChickenPowerUp && randomChance < 0.15; 

            let isFlying = Math.random() < 0.5; 
            if (state.score < state.flyingObstacleThreshold) {
                isFlying = false; 
            }

            if (isChickenPowerUp) {
                item.classList.add('power-up');
                item.textContent = EMOJIS.invincibilityPowerUp;
            } else if (isToyItem) {
                item.classList.add('toy-item');
                const randomToy = TOY_IMAGES[Math.floor(Math.random() * TOY_IMAGES.length)];
                item.classList.add(randomToy.replace('.png', '')); 
                item.style.backgroundImage = `url('${randomToy}')`;
            } else {
                item.classList.add('obstacle');
                if (isFlying) {
                    item.textContent = currentBiome.flyingObstacles[Math.floor(Math.random() * currentBiome.flyingObstacles.length)];
                } else {
                    item.textContent = currentBiome.groundObstacles[Math.floor(Math.random() * currentBiome.groundObstacles.length)];
                }
            }
            
            if (isFlying) item.classList.add('flying-type');
            else item.classList.add('ground-type');

            elements.gameWorld.appendChild(item); // Append to game-world

            const speedMultiplier = 1 + (state.score * 0.01); 
            let animationSpeed = Math.max(0.8, state.obstacleBaseSpeed / speedMultiplier); 
            
            item.style.setProperty('--item-animation-duration', `${animationSpeed}s`);

            if (item.classList.contains('flying-type')) {
                // Now these values are based on the BASE offset, and CSS variables apply the scale
                item.style.bottom = `calc(var(--ground-height) + var(--obstacle-flying-offset) + ${Math.random() * 70 * state.gameScale}px)`; 
            } else {
                item.style.bottom = `var(--ground-height)`; 
            }

            item.dataset.passed = 'false'; 
        }

        function updateScore(scoreAmount = 1, xpAmount = 0) {
            state.score += scoreAmount;
            elements.scoreNumber.textContent = state.score;
            applyScoreEffect();
            checkConfetti();
            checkBiomeChange(); 
            checkGameSpeed(); 
            if (xpAmount > 0) {
                addXP(xpAmount);
            }
        }

        function checkGameSpeed() {
            const speedFactor = 1 + (state.score * 0.015); 
            // Update CSS variables, not directly styles
            document.documentElement.style.setProperty('--ground-animation-duration', `${Math.max(1.0, state.baseGameSpeed / speedFactor)}s`);
            document.documentElement.style.setProperty('--clouds-animation-duration', `${Math.max(5, 25 / speedFactor)}s`);

            const newObstacleInterval = Math.max(state.minObstacleInterval, state.normalObstacleInterval / speedFactor);
            if (Math.abs(newObstacleInterval - state.lastObstacleInterval) > 50) { 
                if (state.obstacleInterval) clearInterval(state.obstacleInterval);
                state.obstacleInterval = setInterval(createItem, newObstacleInterval);
                state.lastObstacleInterval = newObstacleInterval;
            }

            // Also update the animation duration for all *existing* items
            document.querySelectorAll('.obstacle, .power-up, .toy-item').forEach(item => {
                const itemSpeedMultiplier = 1 + (state.score * 0.01);
                const itemAnimationSpeed = Math.max(0.8, state.obstacleBaseSpeed / itemSpeedMultiplier);
                item.style.setProperty('--item-animation-duration', `${itemAnimationSpeed}s`);
            });
        }


        const scoreEffects = ['score-effect-1', 'score-effect-2', 'score-effect-3', 'score-effect-4'];
        function applyScoreEffect() {
            const randomEffect = scoreEffects[Math.floor(Math.random() * scoreEffects.length)];
            elements.scoreNumber.classList.add(randomEffect);
            setTimeout(() => {
                elements.scoreNumber.classList.remove(randomEffect);
            }, 150); 
        }

        function checkConfetti() {
            if (state.score > 0 && state.score % 10 === 0) {
                createConfetti();
            }
        }

        function checkFireConfetti() {
            if (state.toysCollectedInStreak > 0 && state.toysCollectedInStreak % 5 === 0) {
                createFireConfetti();
                state.toysCollectedInStreak = 0; 
            }
        }

        function checkBiomeChange() {
            if (state.score > 0 && (state.score % state.biomeChangeInterval === 0) && (state.score !== state.lastBiomeChangeScore)) { 
                state.biomeCurrentIndexInOrder = (state.biomeCurrentIndexInOrder + 1) % BIOMES.length; 
                setBiome(state.biomeOrder[state.biomeCurrentIndexInOrder]);
                state.lastBiomeChangeScore = state.score;
            }
        }

        function addXP(amount) {
            state.playerXP += amount;
            if (state.playerXP >= state.xpToNextLevel) {
                state.playerLevel++;
                state.playerXP -= state.xpToNextLevel; 
                state.xpToNextLevel = Math.round(state.xpToNextLevel * 1.2); 
            }
            localStorage.setItem('shibaPlayerXP', state.playerXP);
            localStorage.setItem('shibaPlayerLevel', state.playerLevel);
            localStorage.setItem('shibaXpToNextLevel', state.xpToNextLevel); 
            updateXPDisplay(amount); 
        }

        function updateXPDisplay(xpGained = 0) {
            const xpPercentage = (state.playerXP / state.xpToNextLevel) * 100;
            elements.xpBarFill.style.width = `${xpPercentage}%`;
            elements.playerLevelDisplay.textContent = state.playerLevel; 

            if (xpGained > 0) {
                const xpText = document.createElement('span');
                xpText.classList.add('xp-gain-text');
                xpText.textContent = `+${xpGained} XP`;
                // Append to game-container (the main scaling div) to ensure its position is correct
                elements.gameContainer.appendChild(xpText); 

                // Position relative to game-container. CSS will handle the transformX(-50%)
                xpText.style.top = `${elements.gameContainer.clientHeight * 0.15}px`; 
                xpText.style.left = `${elements.gameContainer.clientWidth / 2}px`;

                setTimeout(() => xpText.remove(), 800); 
            }
        }

        function gameLoop() {
            // Gravity and jump strength are scaled in handleJumpStart
            state.shibaY -= state.velocityY; 
            state.velocityY += state.gravity * state.gameScale; // Gravity also needs to scale

            // Collision with ground based on scaled groundHeight
            if (state.shibaY <= state.groundHeight) { 
                state.shibaY = state.groundHeight;
                state.velocityY = 0;
                state.isJumping = false; 
                elements.shiba.style.transform = `translateY(0px) rotate(0deg)`; 
                if (state.jumpHoldTimer) {
                    clearTimeout(state.jumpHoldTimer);
                    state.jumpHoldTimer = null;
                }
            } else if (state.velocityY > 0) { 
                elements.shiba.style.transform = `translateY(0px) rotate(10deg)`; 
            }

            // Apply scaled position to CSS
            elements.shibaContainer.style.bottom = `${state.shibaY}px`;

            checkCollisions();
            checkItemPassage(); 
        }

        function checkCollisions() {
            // Get Shiba's position and size in the scaled game world
            const shibaRect = elements.shibaContainer.getBoundingClientRect();
            
            document.querySelectorAll('.obstacle, .power-up, .toy-item').forEach(item => {
                const itemRect = item.getBoundingClientRect();
                
                const collisionOverlapFactor = 0.35; // Still applies as a ratio
                
                if (shibaRect.right > itemRect.left + (itemRect.width * collisionOverlapFactor) &&
                    shibaRect.left < itemRect.right - (itemRect.width * collisionOverlapFactor) &&
                    shibaRect.bottom > itemRect.top + (itemRect.height * collisionOverlapFactor) &&
                    shibaRect.top < itemRect.bottom - (itemRect.height * collisionOverlapFactor)) {
                    
                    if (!item.hasAttribute('data-collected') && !item.hasAttribute('data-collided')) {
                        if (item.classList.contains('power-up')) { 
                            activateInvincibility();
                            item.remove(); 
                            item.setAttribute('data-collected', 'true');
                            state.toysCollectedInStreak = 0; 
                        } else if (item.classList.contains('toy-item')) {
                            updateScore(10, 150); 
                            item.remove();
                            item.setAttribute('data-collected', 'true');
                            state.toysCollectedInStreak++; 
                            checkFireConfetti(); 
                        }
                        else if (item.classList.contains('obstacle')) { 
                            item.setAttribute('data-collided', 'true');
                            if (!state.isInvincible) {
                                endGame();
                            } else {
                                item.remove(); 
                            }
                            state.toysCollectedInStreak = 0; 
                        }
                    }
                }
            });
        }

        function checkItemPassage() {
            document.querySelectorAll('.obstacle, .power-up, .toy-item').forEach(item => {
                const itemRect = item.getBoundingClientRect();
                const gameWorldRect = elements.gameWorld.getBoundingClientRect(); // Get game-world's viewport rect

                // Calculate item's right edge relative to the game-world's left edge
                const itemRightInGameWorld = itemRect.right - gameWorldRect.left;

                // Threshold is the width of the item, since the CSS animation takes it to `calc(0% - var(--obstacle-size))`
                const removalThreshold = 0 - (item.offsetWidth); // item's own width is fine here.
                
                if (itemRightInGameWorld < removalThreshold && item.parentNode) {
                    if (item.classList.contains('obstacle') && item.dataset.passed === 'false' && !item.hasAttribute('data-collided')) {
                        updateScore(1, 25); 
                        item.dataset.passed = 'true'; 
                    } else if ((item.classList.contains('toy-item') || item.classList.contains('power-up')) && !item.hasAttribute('data-collected')) {
                        if (item.classList.contains('toy-item')) {
                            state.toysCollectedInStreak = 0; // If you miss a toy, streak breaks
                        }
                    }
                    item.remove(); 
                }
            });
        }
        
        function activateInvincibility() {
            state.isInvincible = true;
            elements.shiba.classList.add('invincible');
            elements.invincibleMessage.classList.add('visible'); 

            setTimeout(() => {
                state.isInvincible = false;
                elements.shiba.classList.remove('invincible');
                elements.invincibleMessage.classList.remove('visible'); 
            }, 5000); 
        }
        
        function createPoofEffect() {
            const shibaRect = elements.shiba.getBoundingClientRect();
            const gameWorldRect = elements.gameWorld.getBoundingClientRect(); 
            
            for (let i = 0; i < 15; i++) {
                const p = document.createElement('div');
                p.textContent = '🐕';
                p.classList.add('particle');
                
                // Position particles relative to the game-world's top-left corner
                const shibaCenterGameX = shibaRect.left - gameWorldRect.left + shibaRect.width / 2;
                const shibaCenterGameY = shibaRect.top - gameWorldRect.top + shibaRect.height / 2;

                p.style.top = `${shibaCenterGameY}px`;
                p.style.left = `${shibaCenterGameX}px`;
                
                // Randomize particle movement relative to scaled shiba size
                const randomX = (Math.random() * 60 - 30) * state.gameScale;
                const randomY = (Math.random() * 60 - 30) * state.gameScale;
                p.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg) translateX(${randomX}px) translateY(${randomY}px)`;
                
                elements.gameWorld.appendChild(p);
                setTimeout(() => p.remove(), 800);
            }
        }

        function createConfetti() {
            const numConfetti = 50;
            const gameWorldRect = elements.gameWorld.getBoundingClientRect();
            for (let i = 0; i < numConfetti; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                confetti.style.backgroundColor = CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)];
                
                // Position confetti relative to the game world
                confetti.style.left = Math.random() * gameWorldRect.width + 'px';
                confetti.style.top = (Math.random() * -gameWorldRect.height / 2) + 'px'; 
                
                confetti.style.animationDelay = (Math.random() * 0.8) + 's';
                confetti.style.animationDuration = (2 + Math.random() * 1.5) + 's'; 
                
                confetti.style.transform = `rotate(${Math.random() * 360}deg)`;

                elements.gameWorld.appendChild(confetti);
                setTimeout(() => confetti.remove(), parseFloat(confetti.style.animationDuration) * 1000 + parseFloat(confetti.style.animationDelay) * 1000);
            }
        }

        function createFireConfetti() {
            const numFireConfetti = 30; 
            const gameWorldRect = elements.gameWorld.getBoundingClientRect();
            for (let i = 0; i < numFireConfetti; i++) {
                const fireConfetti = document.createElement('div');
                fireConfetti.classList.add('fire-confetti');
                fireConfetti.textContent = EMOJIS.fireConfetti;
                
                // Position fire confetti relative to the game world
                fireConfetti.style.left = Math.random() * gameWorldRect.width + 'px';
                fireConfetti.style.top = (Math.random() * -gameWorldRect.height / 3) + 'px'; 
                
                fireConfetti.style.animationDelay = (Math.random() * 0.5) + 's';
                fireConfetti.style.animationDuration = (1 + Math.random() * 0.5) + 's'; 
                fireConfetti.style.transform = `rotate(${Math.random() * 360}deg)`;

                elements.gameWorld.appendChild(fireConfetti);
                setTimeout(() => fireConfetti.remove(), parseFloat(fireConfetti.style.animationDuration) * 1000 + parseFloat(fireConfetti.style.animationDelay) * 1000);
            }
        }


        function endGameCleanup() {
            clearInterval(state.gameLoopInterval);
            clearInterval(state.obstacleInterval);
            
            clearInterval(state.bubbleInterval);
            clearInterval(state.rainInterval);
            clearInterval(state.leafInterval);
            clearInterval(state.dustInterval);
            clearInterval(state.snowInterval);
            clearInterval(state.starInterval);

            // Ensure all items are removed from game-world
            document.querySelectorAll('#game-world > .obstacle, #game-world > .power-up, #game-world > .toy-item, #game-world > .special-effect-bubble, #game-world > .raindrop, #game-world > .leaf, #game-world > .dust-particle, #game-world > .snowflake, #game-world > .star, #game-world > .confetti, #game-world > .fire-confetti, #game-world > .xp-gain-text, #game-world > .particle').forEach(el => el.remove());
            
            // xp-gain-text might be appended to gameContainer, so clean that too.
            document.querySelectorAll('#game-container > .xp-gain-text').forEach(el => el.remove());


            elements.ground.style.animationPlayState = 'paused';
            elements.clouds.style.animationPlayState = 'paused';
            document.querySelectorAll('.obstacle, .power-up, .toy-item').forEach(el => {
                el.style.animationPlayState = 'paused';
            });
            
            document.removeEventListener('keydown', handleJumpStart);
            document.removeEventListener('keyup', handleJumpEnd);
            elements.gameContainer.removeEventListener('touchstart', handleJumpStart);
            elements.gameContainer.removeEventListener('touchend', handleJumpEnd);
            elements.gameContainer.removeEventListener('mousedown', handleJumpStart);
            elements.gameContainer.removeEventListener('mouseup', handleJumpEnd);
        }

        function endGame() {
            if (state.isGameOver) return;
            state.isGameOver = true;
            
            if (navigator.vibrate) navigator.vibrate(200);
            
            createPoofEffect();
            elements.shibaContainer.style.display = 'none'; 
            elements.invincibleMessage.classList.remove('visible'); 
            
            endGameCleanup(); 

            let newHighScoreSet = false;
            if (state.score > state.highScore) {
                state.highScore = state.score;
                localStorage.setItem('shibaHighScore', state.highScore);
                elements.highScoreDisplay.textContent = state.highScore;
                elements.splashHighScore.textContent = state.highScore; 
                newHighScoreSet = true;
                addXP(500); 
                elements.highScoreCrownIcon.classList.add('crown-pop'); 
            } else {
                elements.highScoreCrownIcon.classList.remove('crown-pop'); 
            }

            elements.finalScoreDisplay.textContent = state.score;
            elements.finalHighScoreDisplay.textContent = state.highScore;
            elements.gameOverScreen.style.display = 'flex';

            if (newHighScoreSet) {
                elements.newHighScoreMessage.style.display = 'block';
                createConfetti();
            } else {
                elements.newHighScoreMessage.style.display = 'none';
            }
        }

        function restartGame() {
            endGameCleanup(); 
            
            elements.shibaContainer.style.display = 'flex'; 
            elements.shiba.classList.remove('invincible');
            state.isInvincible = false;
            elements.invincibleMessage.classList.remove('visible'); 
            
            state.isGameOver = true; 
            state.score = 0;
            state.lastBiomeChangeScore = 0; 
            elements.scoreNumber.textContent = 0;
            
            elements.gameOverScreen.style.display = 'none';
            elements.newHighScoreMessage.style.display = 'none';
            elements.highScoreCrownIcon.classList.remove('crown-pop'); 

            elements.playButton.style.animation = 'wiggle 2s infinite ease-in-out'; 
            elements.playButton.classList.remove('clicked');

            startIntro(); 
        }
        
        init();
    </script>
</body>
</html>
